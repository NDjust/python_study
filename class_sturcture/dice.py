'''
Reference - Python Cookbook

클래스와 객체

1. 클래스의 인스턴스가 해야할 일들을 기술. (문제 서술) 문장의 길이를 짧게 유지하되, 명사와 동사를 강조하는 것이 중요.

1) 크랩스 게임은 두개의 표준 주사위를 사용한다.
2) 주사위의 각 면에는 1부터 6까지의 숫자가 표시돼 있다.
3) 플레이어가 주사위를 굴린다.
4) 주사위 숫자가 총합에 따라 크랩스 게임의 상태가 변경된다. 개별 주사위 숫자는 게임 상태와 관계가 없디.
5) 두개의 주사위 숫자가 일치하는 경우를 하드라고 하고, 그렇지 않으면 이지라고 한다. (하드-이지 여부는 베팅에 따라 달라질수 있다.)

2. 문장 내의 모든 명사를 식별한다. 명사는 독자적인 클래스가 될 수 있다. 이 클래스들을 협어자라고 부르는데, 예를 들어 플레이와 게임은
협업자들이다. 명사는(객체가 아니라) 객체 내의 속성이 될 수 있다. 예를 들면 주사위의 면과 점수는 주사위 객체의 속성이다.

3. 문장 내의 모든 동사를 식별. 동사는 일반적으로 클래스 내의 메소드가 된다. 예를들어 "굴렸다"와 "일치한다"는 메소드다.
떄로는 다른 클래스의 메소드가 되기도 한다. "상태를 변경한다"는 Craps 클래스에 적용된다.

4. 형용사를 식별한다. 형용사는 명사를 분명히 하는 단어 또는 문구다. 객체의 속성이 되는 경우가 많으며, 가끔은 객체간의 관계를
설명하기도 한다. 예를 들어 주사위 총합(the total of the dice)에서 the total of는 the dice를 수식하므로, 형용사 역활을 하는 전치사구에 해당한다.
총합의 값은 주사위 쌍 객체의 속성이다.


명사는 어떤 사물을 나타냄.
좋은 서술문은 추상적 개념보다는 형태를 갖춘 실제 사물에 초점을 맞춰야 한다.

실제 사물의 눈에 보이는 특징을 먼저 서술하거, 그다음에 이러한 특징을 제공하는 추상적 구현을 찾는 편이 쉽다.

예를 들어 주사위를 굴리는 것은 메소드를 정의해 모델링 할 수 있는 물리적인 동작이다. 주사위 굴리기는 분명히 객체의 상태를 변경한다.
다만 아주 드물게 다음 상태가 이전상태와 동일하다.

형용사는 헷갈리 때가 많다. 형용사의 활요에 관한 일반적인 설명은 다음과 같다.

- 처음, 마지막, 대부분, 다음, 이전 등의 형용사는 해석이 간단하다. 지연 계산일 경우는 메소드, 즉시 계산일 경우는 속성으로 구현된다.
- 주사위 총합처럼 형태가 더 복잡할 때도 있다. 이것은 명사와 전치사가 합쳐진 형용사구로서, 역시 메소드 혹은 속성으로 구현될 수 있다.
- 소프트웨어 내의 다른 객체를 포함하기도 한다. 예를 들어 크랩스 게임의 상태에서 state of는 다른 객체인 Craps를 수식하고 있다.
이것은 분명히 주사위 자체와는 별로 관련이 없는 대신에 주사위 객체와 게임 객체 간의 관계를 반영하는 것이다.
- 문제 서술에 주사위는 게임의 일부라는 문장이 있다고 치자. 이 문장은 게임 객체와 주사위 객체 간에 어떤 관계가 존재함을 분명히 서술하고 있다.
여기서 are part of  전치사구는 다른 객체의 관점에서는 반대의 문장으로 표현될 수 있다. 게임은 주사위를 포함한다가 되는 것이다.
이런 연습을 통해 객체들 간의 관계를 명확히 파악할 수 있다.

파이썬에서 객체의 속성은 기본적으로 동적이다. 다시 말해, 고정된 속성 리스트를 지정하지 않는다. 클래스 정의의 __init__() 메소드에서 
속성의 일부 혹은 전부를 초기화할 수 있다. 속성들이 동적이기 떄문에 클래스 설계에 상당한 유연성이 보장된다.

좋은 클래스 설계 원칙 S.O.L.I.D

- Single Responsibility 원칙 : 한 개의 클래스는 분명히 정의된 한 개의 책임만 져야 한다.
- Open / Closed : 클래스는(상속 등을 통해) 확장에 개방적이되, 변경에는 폐쇠적이어야 한다. 기능 추가나 변경을 위해 코드를 건드릴 필요가 없도록 
클래스를 설계해야 한다.
- Liskov Substitution : 슈퍼 클래스 대신에 서브 클래스를 사용 할 수 있도록 상속을 설계해야 한다.
- Interface Segregation : 서로 협업하는 클래스들은 가급적 덜 상호 의존적이어야 한다. 이를 위해서는 문제를 다수의 작은 클래스들로 분해하는 것이 바람직하다.
- Dependency Inversion : 다른 클래스에 직접적으로 의존하는 것은 바람직하지 않다. 의존 대상을 추상 클래스로 만들고 이 추상 클래스 대신에 
구체적인 구현 클래스를 사용하는 편이 낫다.



'''

class Dice:

    def __init__(self):
        self.faces = None

    def roll(self):
        import random
        self.faces = (random.randint(1, 6), random.randint(1, 6))

    def total(self):
        return sum(self.faces)

    def hardway(self):
        return self.faces[0] == self.faces[1]

    def easyway(self):
        return self.faces[0] != self.faces[1]


if __name__ == "__main__":
    import random
    print(random.seed(1))
    d1 = Dice()
    d1.roll()
    print(d1.total())
    import inspect
    inspect.getsource(list)